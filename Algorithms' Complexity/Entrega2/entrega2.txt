

Nome: Gustavo Hammerschmidt.


1)
	

	function T(n)

		if n == 0					#C1 <- 1

			return 1				#C2 <- 1

		else					

			return T(int(n/2)) + 1	#C3 <- 1 (linear) 

		endif

	end


	t(3)
		t(2) + 1
			t(1) + 1 + 1
				t(0) +  1 + 1 + 1
					1 + 1 + 1 + 1
				1 + 1 + 2
			1 + 3
		4



	T(n) = 1, 			se n = 0
		 = T(n/2) + 1,  se n > 0

	n <- 0:   Tn <- 1
	n <- 1:   Tn <- T(0) + 1 <- 1 + 1 <- 2
	n <- 2:	  Tn <- T(1) + 1 <- T(0) + 1 <- 1 + 1 <- 2


	T(n) <- (chamada de função & chamada de retorno) * n 

	T(n) <-	O(n)


2)


	#	C1 + ... + C9 = 4 * C4 + 6 = 4n + 6 = O(n)  
	##
	int	partition(int *a, int left,	int	right, int pivot){	
		
		int	pos, i;														# C1 -> 2
		swap(a,	pivot,	right);											# C2 -> 1
		pos	=	left;													# C3 -> 1
		
		for(i	=	left;	i	<	right;	i++)	{					# C4 -> (right - 1) - left
			
			if	(a[i]	<	a[right])	{								# C5 -> C4
			
				swap(a,	i,	pos);										# C6 -> C4 * 1
				pos++;													# C7 -> C4 * 1
			
			}

		}	

		swap(a,	right,	pos);											# C8 -> 1
		return	pos;													# C9 -> 1

	}	


	# C1 + ... + C3 = 3 = O(1)
	##
	void	swap(int	*a,	int i,	int	j){	
	
		int	t	=	a[i];												# C1 -> 1
		a[i]	=	a[j];												# C2 -> 1
		a[j]	=	t;													# C3 -> 1
	
	}



	#	C1 + ... + C4 = 2 * log(n) + n + 1 = O(n * log(n)) 
	##
	void	quick(int	*a,	int	left,	int	right) {

		if	(left	<	right)	{	

			int	pivot	=	(left	+	right)	/	2;			 	# C1 -> 1
			int pos	=	partition(a,left,right,pivot);				# C2 -> n
			quick(a,	left,	pos	-	1);							# C3 -> log (n)
			quick(a,	pos	+	1,	right);							# C4 -> log (n)
		
		}	

	}	


	void	main(){	

		int	v[]	=	{4,3,2,10,20,5,6,8,11,12};						# C1 ->	1
		quick(v,	0,10);											# C2 -> n * log(n) 
		
	}

	Encontrar	a	equação	de	recorrência	do	quicksort

		- 2 * log(n) + n + 1	

	Expressar	o	tempo	de	execução	em	função	do	tamanho	
	da	entrada	de	dados	na	forma	de	recorrência—resolver	a	
	equação	de	recorrência;

		- Melhor caso: 2 * log(n) + n + 1 = O (n * log(n))

		- Pior caso: 2 * log(n-1) + O(n) = O (n^2)

	Expressar	a	complexidade	na	notação	O.	

		O (n * log n)

	Mostrar	que	f(n)	<=	O(g(n)),	onde	g(n)	=	n2	


		log 10 -> 1  & n ^ 2 ~ n=10 :: 10 * 10 * 10 * ...

		Crescimento logarítmico < Crescimento Exponencial. 

		Portanto:

			f(n) = n *  log n  &  g(n) = n^2

			-> f(n) <= O(g(n))


3) 

	
	0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...


			| 0 				se n = 0	
	F(n) =  | 1					se n = 1
			| F(n-1) + F(n-2) 	se n > 1


	Dado o valor de n, qual é o n-ésimo elemento da sequência.


	F(n) = F(n-1) + F(n-2)

		 = (F(n-2) + F(n-3)) + (F(n-3) + F(n-4))

		 = (F(n-3) + F(n-4) + F(n-4)+F(n-5)) + (F(n-4)+F(n-5) + F(n-5)+F(n-))

		 = .... + f(0) + f(1) + ....



		 = 2 * f(n-1) + Math.ceil( (n-2) / 2 ) * f(1)



		 f (3) = f(1) + f(2)

		 f(2) = f(1) + f(0)

		 f(4) = f(2) + f(3)


		 				f(4)
		 		f(3)		f(2)
		 	f(2)	f(1)	f(0) f(1)
		 f(0) f(1)





		 								f(5)
		 				f(4)
		 		f(3)		f(2)				f(3)
		 	f(2)	f(1)	f(0) f(1)		f(2)	f(1)
		 f(0) f(1)							f(0)f(1)

		 	

		 							f(5)							f(4)
		 				f(4)
		 		f(3)		f(2)				f(3)				
		 	f(2)	f(1)	f(0) f(1)		f(2)	f(1)
		 f(0) f(1)							f(0)f(1)

		 	

		 			f(6)


		 				f(4)

